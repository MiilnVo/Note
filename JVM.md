### JVM



#### 内存区域

![x8cps](http://img.miilnvo.xyz/x8cps.png)

* 栈（Stack）

  每条线程都有一个栈，每个栈都有很多栈帧，每个栈帧对应一个方法

  在编译时已经确定了栈的大小，写在了属性表里的Code中

  栈帧：支持JVM进行方法调用和方法执行的数据结构

  * 局部变量表：以Slot为最小单位，第0位的Slot默认表示this，Slot可以复用
  * 操作数栈：一个后入先出的栈，真正进行操作的地方
  * 动态连接：指向运行时常量池中该栈帧对应方法的符号引用（执行的是某个子类的实现方法）
  * 返回地址：存放调用此方法的程序计数器的值

* 堆（Heap）

  存储所有的对象以及数组

  年轻代 : 老年代 = 1 : 2

  Eden : Survivor = 8 : 1

  * 分配策略
    1. 对象优先在Eden区分配
    2. 大对象直接进入老年代
    3. 长期存活的对象将进入老年代（默认经历15次回收的对象）
    4. 动态年龄计算：年龄从小到大进行累加，当加入某个年龄段后，累加和超过Survivor区域*TargetSurvivorRatio时，比这个年龄大的对象进行晋升
  5. 老年代空间担保：当Eden区满时触发垃圾回收，在把存活对象复制到Survivor区时其空间也满了，则会把存活对象放到老年代
    
  * 对象

    * 对象头（Mark Word）：哈希码、GC分代年龄、锁状态标志等 + 类型指针

      > 根据对象的状态复用存储空间

    * 实例数据

    * 对齐填充：对象的起始地址必须是8的整数倍

    创建流程：new => 加载类 => 分配堆内存 => 初始化为零值 => 设置对象头 => 执行`<init>`

    直接指针访问：栈的局部变量表中的reference类型存储的是堆中的对象地址

  > 内存溢出：创建太多对象导致空间不足
  >
  > 内存泄漏：无用的对象没有回收

  【参考】

  <https://www.zhihu.com/question/41922036>

* 方法区

  存储已加载的类信息、常量、静态变量等

* 常量池

  * 字符串常量池：本质上是一个StringTable的哈希结构
  * [Class文件常量池](#常量池)：每个Class文件都有一个常量池，包含各种字面量和符号引用
  * 运行时常量池：加载Class文件常量池后的状态

  > v1.7之前：运行时常量池逻辑包含字符串常量池，两者都存放在方法区（永久代）
  >
  > v1.7之后：字符串常量池单独从方法区移到了堆，运行时常量池剩下的东西还在方法区（永久代/元空间）



#### 垃圾收集

##### Q1：在什么时候回收？

堆中相应的区域将要满时

##### Q2：对哪些对象回收？

先通过可达性分析算法，对找到的对象进行标记，再对那些<u>无法复活的对象</u>进行回收

* 统计方式

  * 引用计数：无法解决对象之间相互循环引用的问题（JVM不使用此方式）

  * 可达性分析：从GC Roots开始通过引用链判断对象是否可达

* 引用类型（v1.2）

  * 强引用：GC不会回收此对象
  * 软引用（SoftReference）：在内存不足时优先进行回收
  * 弱引用（WeakReference）：只能生存到下一次GC前
  * 虚引用（PhantomReference）：等于无

* `finalize()`方法

  对象在被回收前会执行（仅一次）被重写过的此方法，如果在方法内重新关联上引用链，则此对象复活

##### Q3：进行怎么样的回收？

绝大部分都是分代收集算法

* Young GC / Minor GC：只收集年轻代
* Old GC：只收集老年代，只有CMS是这个模式
* Mixed GC：收集整个年轻代以及部分老年代，只有G1是这个模式

* Full GC：收集整个堆以及永久代（在v1.8被元空间代替）

  > 触发条件：
  >
  > 1. Young GC的平均晋升大小比目前老年代的剩余空间大
  > 
  > 2. System#`gc()`和Heap Dump操作
  >
  > 3. 如果有永久代且没有足够的空间时

| 垃圾收集器                                   | 收集算法        | 特点                                                         |
| -------------------------------------------- | --------------- | ------------------------------------------------------------ |
| Serial + Serial Old                          | 复制 + 标记整理 | 单线程串行，回收时会停止其他所有的工作线程，适用于Client模式 |
| ParNew + X                                   | 复制 + X        | 是Serial并发回收的版本                                       |
| X + CMS（Concurrent Mark Sweep）             | X + 标记清除    | 延迟优先级，耗时最久的第二步标记和第四步清除都可以与用户线程<u>并发</u>执行 |
| Parallel Scavenge + Parallel Old（v1.8默认） | 复制 + 标记整理 | 吞吐量优先级，多线程<u>并行</u>收集                          |
| G1（v1.7）                                   | 复制 & 标记整理 | 延迟优先级，把内存分为多个大小相同的区域Region               |
| ZGC（v1.11）                                 |                 | 延迟优先级，10ms的延迟不会随着堆的增大而增大                 |

##### Q4：如何进行调优

目标：吞吐量 vs 延迟

监控：开启GC日志

方案：GC种类、空间比例（活跃数据）、参数

> 当存在大量的短期对象时，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大。因为复制成本远高于扫描成本，所以Young GC时间更多取决于GC后存活对象的数量，而非Eden区的大小。调整年轻代和年老代的比例就是一个<u>找平衡的过程</u>

> 初始堆大小和最大堆相同，可以防止每次GC后进行内存重新分配

> 最大堆的设置建议在物理内存的1/2~2/3之间

【参考】

https://juejin.im/post/6844903974676463629

https://www.jianshu.com/p/c3a8a108da00

https://tech.meituan.com/2017/12/29/jvm-optimize.html

https://club.perfma.com/article/1870333



#### 编译期

> 前端编译器：javac、ECJ

编译流程：

1. 语法分析和填充符号表

2. 注解器处理

3. 语义分析：检查变量使用前是否已声明、变量与赋值类型是否匹配、对常量进行折叠

   ​                   方法是否有返回值、检查异常是否都已被正确处理

   ​                   解语法糖（把泛型、自动装拆箱、变长参数、遍历循环等还原成基础语法）

4. 生成字节码文件：会自动添加`<init>`和`<clinit>`



#### 类文件

| 类型           | 名称             | 数量           |
| -------------- | ---------------- | -------------- |
| u4             | 魔数             | 1              |
| u2             | 次版本号         | 1              |
| u2             | 主版本号         | 1              |
| u2             | 常量池的个数     | 1              |
| cp_info        | 常量池的内容     | 常量池个数 - 1 |
| u2             | 访问标志         | 1              |
| u2             | 本类名的索引     | 1              |
| u2             | 父类名的索引     | 1              |
| u2             | 接口的个数       | 1              |
| u2             | 接口名的索引     | 接口个数       |
| u2             | 成员变量表的个数 | 1              |
| field_info     | 成员变量表的内容 | 字段表的个数   |
| u2             | 方法表的个数     | 1              |
| method_info    | 方法表的内容     | 方发表个数     |
| u2             | 属性表的个数     | 1              |
| attribute_info | 属性表的内容     | 属性表的个数   |

* <span id="常量池">常量池</span>

  * 字面量

    文本字符串：`String str="abc"`的abc

    被声明为final的常量值：`final int i = 257`的257

  * 符号引用

    类、方法和接口的全限定名：com/miilnvo/TestClass

    属性的名称和描述符：`String str="abc"`的str 和 Ljava/lang/String

    方法的名称和描述符：`public int inc() {...}`的inc 和 ( )I

    > 符号引用不经过运行期转换的话无法得到真正的内存入口地址

* 成员变量表

  访问标记 + 成员变量名称的索引 + 成员变量描述符的索引 + 属性表的个数 + 属性表的内容

  ```java
  public final int num1 = 5;
  ```

  ![0q3w3](http://img.miilnvo.xyz/0q3w3.png)

* 方法表

  访问标记 + 方法名称的索引 + 方法描述符的索引 + 属性表的个数 + 属性表的内容

  没有从父类继承而来的方法

  方法的内容都保存在属性表中Code里，空方法则没有此Code

  包含了编译器自动添加的方法，例：`<init>`

  只要两个方法的描述符不同（名称和参数列表相同，返回值不同），那么就可以同时存在

* 属性表

  | 名称               | 位置                   | 说明                                         |
  | ------------------ | ---------------------- | -------------------------------------------- |
  | Code               | 方法表                 | 方法中的代码编译成的字节码                   |
  | LineNumberTable    | Code                   | 源码中行号与字节码的对应关系                 |
  | LocalVariableTable | Code                   | 栈帧中局部变量表的变量与源码中变量的对应关系 |
  | Exceptions         | 方法表                 | 在方法描述时throws后面的异常                 |
  | InnerClass         | 类                     | 内部类的列表                                 |
  | Signature          | 类、方法表、成员变量表 | 泛型信息                                     |
  | SourceFile         | 类                     | 生成此类文件的源文件名称                     |

> 上述的XXX的索引指的是在Class文件常量池中的位置


> 从字节码的角度，枚举类仅仅是一个继承java.lang.Enum，自动生成了values( )和valueOf( )方法的普通类



#### 加载

* 类加载器

  放在JVM之外

  只有在相同类加载器的前提下，比较两个类是否相同才有意义

  双亲委派模型：先委托父类加载器进行加载

  > 优点：避免重复加载类、避免核心API被篡改

  * 启动类加载器：<JAVA_HOME>\lib
  * 扩展类加载器：<JAVA_HOME>\lib\ext
  * 应用程序类加载器：<Class_Path>
  * 自定义类加载器

* 加载时机（类的主动引用）
  1. new对象
  2. 访问或修改某个类静态成员变量或静态方法
  3. 反射`Class.forName("xxx")`
  4. 子类初始化时先对父类初始化
  5. `main()`方法所在的类

* 加载流程

  加载 => 验证 => 准备 => 解析 => 初始化 => 使用 => 卸载

  1. 加载：通过全限定名获取二进制流，再转化为方法区的数据结构，并在堆中生成Class对象

  2. 验证：保证非源码编译而来的类文件也能符合要求

  3. 准备：为静态成员变量在方法区分配内存并设置初始值

  4. <span id="解析">解析</span>：将常量池内的符号引用替换为目标的直接指针（静态）

     > 为了支持运行时绑定，解析可以在初始化之后再开始

  5. 初始化：执行`<clinit>`（包含对静态成员变量的赋值和static块）
  
     ​               静态语句块对它之后定义的静态成员变量只能赋值，不能访问
  
     ​               会始终先执行父类的`<clinit>`
  
     ​               在多线程环境中能保证只执行一次`<clinit>`
     
     ​               虚拟机规范严格规定了有且只有五种情况必须对类进行初始化（类的主动引用）
  

> 数组类不通过类加载类创建，由JVM直接创建



#### 执行

* 方法调用

  一切方法调用在Class文件里存储的都只是符号引用

  确定被调用方法的版本，并不涉及具体的运行

* [解析](#解析)

  编译期已知，运行期不可变的方法，即非虚方法：静态方法、私有方法、构造方法、父类方法、final方法（invokevirtual）

  对应的字节码指令：`invokestatic`和`invokespercial`

* 分派

  > 两种多态的实现原理

  * 静态分派（重载）

    重载时通过对象的引用类型（即静态类型）与方法的参数类型进行匹配，此过程发生在编译阶段

  * 动态分派（重写）

    `invokevirtual`指令会根据栈顶的对象，按照继承关系从下往上查找相应的方法，再把常量池中方法的符号引用解析到相应的直接引用（多态的体现）

* 流程

  源文件 == javac ==> 类文件 ==> 解释器（解释执行） ==> 输出结果

​                                                       ==> JIT编译器（编译执行） ==> 本地机器码 ==> 执行 ==> 输出结果

  解释执行：逐条翻译字节码为机器码，边处理边执行

  编译执行：生成本地代码后再执行（指后端编译）

  > 对于大部分不常用的代码，采用解释执行的方式可以节省后端编译的时间。而对于一些小部分的热点代码，后端编译成机器码可以提高运行的效率



#### 运行期

> 后端编译器：JIT（Just In Time Compiler）

* 两种类型

  HotSpot内置两个即时编译器

  C1（Client Compiler）：编译速度快

  C2（Server Compiler）：编译质量高

* 三种模式

  混合模式（mixed mode）：两者同时工作

  解释模式（interpreted mode）：编译器完全不工作

  编译模式（compiled mode）：解释器会在必要时工作

* 编译条件

  多次调用的方法：通过方法计数器统计相对调用次数

  多次执行的循环体：通过回边计时器统计绝对调用次数

* 优化技术

  > 由即时编译器优化得到的本地代码比由解释器解释字节码后实际执行的本地代码优秀

  内联

  公共子表达式消除

  复写传播

  无用代码消除



#### 性能参数

`-Xms`：初始堆内存

`-Xmx`：最大堆内存

> 默认空余堆内存小于40%时，JVM就会增大堆直到`-Xmx`的最大限制；空余堆内存大于70%时，JVM会减少堆直到`-Xms`的最小限制

`–XX:NewRatio`：设置年轻代和老年代的比例

`-XX:+UseAdaptiveSizePolicy`：使Parallel Scavenge可以自动调节堆空间的大小

`-XX:MaxGCPauseMillis`：设置Parallel Scavenge的最大延迟时间

`-XX:GCTimeRatio`：设置Parallel Scavenge吞吐量的大小，默认值99

`-XX:+UseCompressedOops`：在64位JVM环境下压缩对象的指针，节省内存

`-XX:+PrintGC` / `-XX:+PrintGCDetails`：输出GC日志

`-Xloggc:/.../gc.log`：设置GC日志的路径

`-XX:+PrintTenuringDestribution`：输出GC后Survivor区年龄分布的信息

`-XX:+PrintGCTimeStamps`：输出GC时间戳

`-XX:+PrintGCApplicationStoppedTime`：输出STW时间

`-XX:-UseBiasedLocking`：禁用偏向锁，用于高并发的环境下

【参考】

https://zhuanlan.zhihu.com/p/110517640

https://tech.meituan.com/2017/12/29/jvm-optimize.html

https://blog.csdn.net/renfufei/article/details/55102729

https://segmentfault.com/a/1190000020625913?utm_source=tag-newest

https://segmentfault.com/a/1190000016427465



#### 性能监控

`jsp`：显示Java进程的PID（或者top命令）

`top -Hp [PID]` / `ps -mp [PID] -o THREAD,tid,time`：显示进程中的线程情况

`printf "%x\n" [TID]`：将线程ID转为16进制

`jstack [PID]`：显示线程的栈信息

`jstat -gcutil [PID] 5000 10`：显示GC情况，间隔5秒，查看10次

`jmap -heap [PID]`：显示堆信息

`jmap -dump:live [PID]`：导出堆的详细信息

`jinfo -flags [PID]` / `jcmd [PID] VM.flags`：显示启动参数

> Shallow Heap：实际占用堆的大小
>
> Retained Heap：删除此对象能释放的空间（包含引用）

【参考】

https://blog.csdn.net/lengyue309/article/details/80590119

https://www.cnblogs.com/wuchanming/p/7766994.html

https://www.jianshu.com/p/3667157d63bb